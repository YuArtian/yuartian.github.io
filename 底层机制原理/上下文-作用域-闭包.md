# 作用域-作用域链-闭包
>
> JS夯实之执行上下文与词法环境
> <https://juejin.cn/post/6844904145372053511#heading-1>

## 执行上下文（Execution Context）

执行上下文是用来 跟踪记录 代码运行时环境 的抽象概念
每一次代码运行都至少会生成一个执行上下文，代码都是在执行上下文中运行的

### 执行栈

执行栈是用来管理执行上下文的数据结构，遵循先进后出的原则
一开始会初始化一个全局执行上下文，然后每次调用函数都会生成一个新的执行上下文，压入执行栈中，JS引擎有一个指针 running 指向栈顶元素
函数执行完毕后，会将执行上下文从执行栈中弹出，最后弹出的是全局执行上下文，整个程序执行完毕

## 作用域和作用域链

全局代码存储其变量的地方叫做变量对象（VO），函数存储其变量的叫活动对象（AO），VO 和 AO 都是在预编译时确定其内容，然后在代码运行时被修改值
<!-- VO和AO都是在es1、3中才存在的概念，在现在的 es5+ 中已经不存在VO和AO的概念，取而代之的是一个叫做 词法环境（Lexical environment） -->

执行上下文创建会做两件事情：

- 创建词法环境 Lexical Environment
- 创建变量环境 Variable Environment

词法环境中包含了 环境记录（Environment Record） 和 外部词法环境的引用（outer）
其中 outer 指向了函数的外部词法环境，形成了作用域链

### 词法环境（Lexical Environment）
>
> <https://zhuanlan.zhihu.com/p/159369973>

词法环境类型：

- 全局环境（Global Environment）
   在 JavaScript 代码运行伊始，宿主(浏览器、NodeJs等)会事先初始化全局环境，在全局环境的 环境记录（Environment Record） 中会绑定内置的全局对象(Infinity等)或全局函数(eval、parseInt等)，其他声明的全局变量或函数也会存储在全局词法环境中
   全局环境的 outer 引用为 null
- 函数环境（Function Environment）
   每一次调用函数时都会产生函数环境，在函数环境中会涉及this的绑定或super的调用
   在环境记录中也会记录该函数的length和arguments属性，以及函数内部声明的变量和函数，this 的指向等
   函数环境的 outer 引用为函数的外部词法环境
- 模块环境（Module Environment）
   模块环境的 outer 引用指向全局环境

词法环境由三部分组成：

- 环境记录（Environment Record）
   代码中声明的变量和函数都会存放在 Environment Record 中等待执行时访问
  - 函数环境记录（Function Environment Record）
      ECMA针对函数式环境记录会额外增加一些内部属性
    - `[[NewTarget]]`：指向 new.target，用于判断函数是否是通过 new 调用的
    - `[[ThisValue]]`：函数内调用 this 时引用的地址，我们常说的函数 this 绑定就是给这个内部属性赋值
    - `[[ThisBindingStatus]]`：若等于 lexical，则为箭头函数，意味着this是空的；
- 对外部词法环境的引用（outer）
   词法环境的 outer 引用指向了函数的外部词法环境，形成了作用域链
- this 绑定
   this 绑定的目的是在执行上下文创建之时就明确 this 的指向，在函数执行过程中读取到正确的 this 引用的对象

### 变量环境（Variable Environment）

在 ES6 前，声明变量都是通过var关键词声明的，在ES6中则提倡使用let和const来声明变量，为了兼容var的写法，于是使用变量环境来存储var声明的变量
变量环境本质上仍是词法环境，但它只存储 var 声明的变量，这样在初始化变量时可以赋值为 undefined
<!-- let/const 与 var 的区别 -->
- 存放位置不同
  - var 存放在变量环境中
  - let/const 存放在词法环境中
- 初始化不同
  - var 声明的变量会被初始化为 undefined
  - let/const在初始化时会被置为`<uninitialized>`标志位，提前读取变量会报 ReferenceError的错误。（这个特性又叫暂时性死区）
- 块级作用域
   > 块语句
   > <https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/block>
   在ECMA标准中提到，当遇到 块语句 时，将会新建一个环境记录，在块中声明的let/const变量、函数、类都存放这个新的环境记录中，这些变量与块强绑定，在块外界则无法读取这些声明的变量
  - var 没有块级作用域，let/const 只在块级作用域中有效

## 闭包
>
> <https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures>
> <https://juejin.cn/post/7079995358624874509#heading-2>

## 闭包是什么

闭包（closure）闭包是由 函数 以及 声明该函数的词法环境组合而成的，这个词法环境包含了这个闭包创建时作用域内的所有局部变量
是由于 内层函数 引用了 外层函数 的变量，导致外层函数的变量没有被释放，从而形成了闭包
闭包可以从 内部函数 访问 外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建

- 闭包不一定有 return，return 只是方便外部函数访问内部函数的变量
- 闭包不一定有内存泄漏
- 闭包是 函数 和 声明该函数的词法作用域 的组合。

## 闭包在哪儿

V8 对闭包进行了优化，实现了 Closure 对象，Closure 对象是一个内部对象，保存了内部函数引用的变量，被内部函数的作用域链引用
闭包在当前函数预编译阶段就已经创建了

## 内存泄漏

闭包产生内存泄漏的根本原因是：

   因为 Closure 对象被其所有子函数的作用域链引用，只要有一个子函数没有销毁，Closure 就无法销毁，导致其中的变量也无法销毁，最终产生了内存泄漏
2. 持有了不再需要的函数引用，会导致函数关联的词法环境无法被释放，从而导致内存泄漏

## 总结

js 采用的是词法作用域，也就是函数可以访问的变量在函数定义时就确定了，和函数被调用的位置无关
每一个函数在执行之前都会进行预编译，预编译时会创建一个空的闭包对象。
每当这个函数预编译时遇到其内部的函数声明时，会快速的扫描内部函数使用了当前函数中的哪些变量，将可能使用到的变量加入到闭包对象中，最终这个闭包对象将作为这些内部函数作用域链中的一员。
只有所有内部函数的作用域链都被释放才会释放当前函数的闭包对象，所谓的闭包内存泄漏也就是因为闭包对象无法释放产生的。

## 实际应用场景

实现数据的私有化，封装变量，避免全局变量污染
比如：函数防抖/节流，柯里化，私有方法

## this 指向
>
> <https://juejin.cn/post/6844904145376428045>
