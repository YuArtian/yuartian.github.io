(window.webpackJsonp=window.webpackJsonp||[]).push([[256],{620:function(t,e,a){"use strict";a.r(e);var n=a(45),c=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue-nexttick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-nexttick"}},[t._v("#")]),t._v(" Vue nextTick")]),t._v(" "),a("blockquote",[a("p",[t._v("https://github.com/answershuto/learnVue/blob/master/docs/Vue.js%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0DOM%E7%AD%96%E7%95%A5%E5%8F%8AnextTick.MarkDown")])]),t._v(" "),a("h2",{attrs:{id:"tldr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tldr"}},[t._v("#")]),t._v(" TLDR;")]),t._v(" "),a("ul",[a("li",[t._v("nextTick是Vue的一个异步API，用于在DOM更新后执行回调函数")]),t._v(" "),a("li",[t._v("nextTick的原理是利用了JavaScript中的事件循环机制，将回调函数放入下一个事件循环周期中执行")]),t._v(" "),a("li",[t._v("nextTick的执行逻辑是将回调函数存储到一个队列中，等到下一个事件循环周期开始时依次执行队列中的回调函数。\n如果在回调函数中再次调用 nextTick，则添加的回调函数会在当前队列的末尾执行。")])]),t._v(" "),a("blockquote",[a("p",[t._v("https://set.sh/post/180906-next-tick")])]),t._v(" "),a("h2",{attrs:{id:"nexttick原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nexttick原理"}},[t._v("#")]),t._v(" nextTick原理")]),t._v(" "),a("p",[t._v("在 Vue 中，当数据变化后，DOM 不会立即更新，而是会先进入一个队列中，在下一个事件循环周期中才会去更新 DOM。这样做是为了避免频繁的 DOM 操作，从而提高性能。")]),t._v(" "),a("p",[t._v("Vue 中提供了 nextTick 函数，它可以让我们在 DOM 更新完毕后再进行某些操作，比如获取更新后的 DOM 元素。nextTick 的原理就是利用了 JavaScript 中的事件循环机制，将回调函数放入下一个事件循环周期中执行。")]),t._v(" "),a("p",[t._v("具体来说，当 nextTick 被调用后，Vue 会将回调函数存储到一个队列中，然后在本次事件循环周期内将该队列挂起。等到下一个事件循环周期开始时，Vue 会优先执行该队列中的所有回调函数，这时 DOM 已经更新完毕，我们可以安全地访问更新后的 DOM 元素了。")]),t._v(" "),a("p",[t._v("需要注意的是，由于 nextTick 的回调函数是异步执行的，所以如果需要在 nextTick 回调中获取到最新的数据，必须将回调函数放到组件实例的作用域中，否则无法访问最新的数据")]),t._v(" "),a("h2",{attrs:{id:"多个nexttick的执行逻辑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多个nexttick的执行逻辑"}},[t._v("#")]),t._v(" 多个nextTick的执行逻辑")]),t._v(" "),a("p",[t._v("如果多次调用 nextTick，则所有的回调函数都会被存储到同一个队列中。在下一个事件循环周期开始时，Vue 会依次执行队列中的回调函数，按照它们被添加到队列中的顺序执行。也就是说，先添加的回调函数会先执行，后添加的回调函数会后执行。")]),t._v(" "),a("p",[t._v("需要注意的是，如果在 nextTick 回调函数中再次调用 nextTick，那么它添加的回调函数会放在当前队列的末尾，即最后执行。这是因为当前队列已经在本次事件循环周期中被挂起，新的 nextTick 回调函数只能被添加到下一个事件循环周期的队列中。")]),t._v(" "),a("p",[t._v("总之，nextTick 的执行逻辑是将回调函数存储到一个队列中，等到下一个事件循环周期开始时依次执行队列中的回调函数。如果在回调函数中再次调用 nextTick，则添加的回调函数会在当前队列的末尾执行。")]),t._v(" "),a("h2",{attrs:{id:"vue2-和-vue3中的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2-和-vue3中的区别"}},[t._v("#")]),t._v(" vue2 和 vue3中的区别")])])}),[],!1,null,null,null);e.default=c.exports}}]);