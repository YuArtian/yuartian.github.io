(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{393:function(e,t,s){"use strict";s.r(t);var a=s(45),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"linux命令which-whereis-locate-find的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux命令which-whereis-locate-find的区别"}},[e._v("#")]),e._v(" linux命令which,whereis,locate,find的区别")]),e._v(" "),s("blockquote",[s("p",[e._v("https://zhuanlan.zhihu.com/p/35727707")])]),e._v(" "),s("h1",{attrs:{id:"linux命令which-whereis-locate-find的区别-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux命令which-whereis-locate-find的区别-2"}},[e._v("#")]),e._v(" linux命令which,whereis,locate,find的区别")]),e._v(" "),s("ol",[s("li",[s("strong",[e._v("which")]),e._v("：常用于查找可直接执行的命令。只能查找可执行文件，该命令基本只在$PATH路径中搜索，查找范围最小，查找速度快。默认只返回第一个匹配的文件路径，通过选项 "),s("em",[e._v("-a")]),e._v(" 可以返回所有匹配结果。")]),e._v(" "),s("li",[s("strong",[e._v("whereis")]),e._v("：不只可以查找命令，其他文件类型都可以（man中说只能查命令、源文件和man文件，实际测试可以查大多数文件）。在$PATH路径基础上增加了一些系统目录的查找，查找范围比which稍大，查找速度快。可以通过 "),s("em",[e._v("-b")]),e._v(" 选项，限定只搜索二进制文件。")]),e._v(" "),s("li",[s("strong",[e._v("locate")]),e._v("：超快速查找任意文件。它会从linux内置的索引数据库查找文件的路径，索引速度超快。刚刚新建的文件可能需要一定时间才能加入该索引数据库，可以通过执行updatedb命令来强制更新一次索引，这样确保不会遗漏文件。该命令通常会返回大量匹配项，可以使用 "),s("em",[e._v("-r")]),e._v(" 选项通过正则表达式来精确匹配。")]),e._v(" "),s("li",[s("strong",[e._v("find")]),e._v("：直接搜索整个文件目录，默认直接从根目录开始搜索，建议在以上命令都无法解决问题时才用它，功能最强大但速度超慢。除非你指定一个很小的搜索范围。通过 "),s("em",[e._v("-name")]),e._v(" 选项指定要查找的文件名，支持通配符。")])]),e._v(" "),s("p",[s("strong",[e._v("下面通过一个实际的例子来测试和体会几个命令的差异：")])]),e._v(" "),s("p",[e._v("先通过which找到ls命令的位置")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("tarena@tedu:/$ "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("which")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v("\n/bin/ls\n")])])]),s("p",[e._v("把ls复制到主目录，并把名称修改为newls")]),e._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("tarena@tedu:/$ cp /bin/ls ~/newls\ntarena@tedu:/$ cd ~\n")])])]),s("p",[e._v("尝试用which和whereis命令查找newls，由于主目录不在$PATH中（除非你恰巧之前你恰巧把～加入$PATH了），所以都无法找到")]),e._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("tarena@tedu:~$ whereis newls\nnewls:\ntarena@tedu:~$ which newls\ntarena@tedu:~$ \n")])])]),s("p",[e._v("执行以下export命令，把～加入$PATH，然后我们cd到根目录，再次尝试查找newls，发现已经可以找到了")]),e._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("tarena@tedu:~$ export PATH=$PATH:~\ntarena@tedu:~$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin:/home/tarena\ntarena@tedu:~$ cd /\ntarena@tedu:/$ which newls\n/home/tarena/newls\ntarena@tedu:/$ whereis newls\nnewls: /home/tarena/newls\n")])])]),s("p",[e._v("我们再cd到～，然后取消newls的可执行权限")]),e._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("tarena@tedu:/$ cd ~\ntarena@tedu:~$ chmod u-x newls\n")])])]),s("p",[e._v("然后我们再次尝试使用which和whereis查找newls，我们发现whereis可以找到，而which找不到newls。因为which只能用来查找可执行文件，whereis没有该限制。")]),e._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("tarena@tedu:~$ cd /\ntarena@tedu:/$ whereis newls\nnewls: /home/tarena/newls\ntarena@tedu:/$ which newls\n")])])]),s("p",[e._v("这时我们再把newls改名为ls，然后我们尝试用locate命令找出系统中存在的两个ls文件，我们发现会找到大量不是我们要的文件（此处已省略了很多），但这些文件路径中确实包含ls。")]),e._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("tarena@tedu:~$ cd ~\ntarena@tedu:~$ mv newls ls\n/bin/false\n/bin/ls\n/bin/lsblk\n/bin/lsmod\n/bin/ntfsls\n/boot/grub/i386-pc/cbls.mod\n/boot/grub/i386-pc/command.lst\n/boot/grub/i386-pc/crypto.lst\n/boot/grub/i386-pc/fs.lst\n/boot/grub/i386-pc/ls.mod\n/boot/grub/i386-pc/lsacpi.mod\n/boot/grub/i386-pc/lsapm.mod\n/boot/grub/i386-pc/lsmmap.mod\n/boot/grub/i386-pc/lspci.mod\n/boot/grub/i386-pc/moddep.lst\n/boot/grub/i386-pc/partmap.lst\n/boot/grub/i386-pc/parttool.lst\n/boot/grub/i386-pc/terminal.lst\n/boot/grub/i386-pc/video.lst\n...\n")])])]),s("p",[e._v("我们尝试用正则表达式缩小匹配范围")]),e._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("tarena@tedu:~$ locate -r '\\bls$'\n/bin/ls\n/usr/bin/gvfs-ls\n/usr/lib/klibc/bin/ls\n/usr/share/bash-completion/completions/gvfs-ls\n")])])]),s("p",[e._v("我们发现只找到了一个ls，另外一个可能因为系统还没有纳入索引数据库，所以没有找到，我们执行updatedb命令，强制更新一下系统索引，然后再执行一遍locate试试，发现现在可以找到了")]),e._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("tarena@tedu:~$ sudo updatedb\n/bin/ls\n/home/tarena/ls\n/usr/bin/gvfs-ls\n/usr/lib/klibc/bin/ls\n/usr/share/bash-completion/completions/gvfs-ls\n")])])]),s("p",[e._v("find命令全盘查找太慢，所以限制下查找路径，也是同样可以找到")]),e._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("tarena@tedu:~$ find ~ /bin/ -name ls\n/home/tarena/ls\n/bin/ls\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);