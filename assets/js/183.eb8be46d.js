(window.webpackJsonp=window.webpackJsonp||[]).push([[183],{549:function(a,t,n){"use strict";n.r(t);var e=n(45),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"尾调用和尾递归"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#尾调用和尾递归"}},[a._v("#")]),a._v(" 尾调用和尾递归")]),a._v(" "),n("h2",{attrs:{id:"尾调用-tail-call"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#尾调用-tail-call"}},[a._v("#")]),a._v(" 尾调用（Tail Call）")]),a._v(" "),n("p",[a._v("尾调用是指 a 函数的最后一步是调用 b 函数，而且没有其他操作，b 函数中也没有引用到 a 函数中的变量")]),a._v(" "),n("p",[a._v("尾调用之所以与其他调用不同，就在于它的特殊的调用位置")]),a._v(" "),n("p",[a._v("函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数"),n("code",[a._v("A")]),a._v("的内部调用函数"),n("code",[a._v("B")]),a._v("，那么在"),n("code",[a._v("A")]),a._v("的调用帧上方，还会形成一个"),n("code",[a._v("B")]),a._v("的调用帧。等到"),n("code",[a._v("B")]),a._v("运行结束，将结果返回到"),n("code",[a._v("A")]),a._v("，"),n("code",[a._v("B")]),a._v("的调用帧才会消失。如果函数"),n("code",[a._v("B")]),a._v("内部还调用函数"),n("code",[a._v("C")]),a._v("，那就还有一个"),n("code",[a._v("C")]),a._v("的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）")]),a._v(" "),n("p",[a._v("尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了")]),a._v(" "),n("p",[a._v("也就是说，尾调用中，只有一个调用帧")]),a._v(" "),n("p",[a._v("注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”")]),a._v(" "),n("p",[a._v("支持 尾调用优化 的浏览器还不够多，貌似只有 Safari")]),a._v(" "),n("h2",{attrs:{id:"尾递归"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#尾递归"}},[a._v("#")]),a._v(" 尾递归")]),a._v(" "),n("p",[a._v("函数调用自身，称为递归。如果尾调用自身，就称为尾递归")]),a._v(" "),n("p",[a._v("递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）")]),a._v(" "),n("p",[a._v("但对于尾递归来说，由于可以进行 尾调用优化，只存在一个调用帧")]),a._v(" "),n("p",[a._v("所以永远不会发生 栈溢出 错误")]),a._v(" "),n("p",[a._v("ES6 严格模式下，尾递归优化才生效")]),a._v(" "),n("h3",{attrs:{id:"递归函数改写"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#递归函数改写"}},[a._v("#")]),a._v(" 递归函数改写")]),a._v(" "),n("p",[a._v("尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身")]),a._v(" "),n("p",[a._v("做到这一点的方法，就是把所有用到的内部变量改写成函数的参数")]),a._v(" "),n("p",[a._v("有两种方法可以改写现有的递归函数")]),a._v(" "),n("div",{staticClass:"language-text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function Fibonacci (n) {\n  if ( n <= 1 ) {return 1};\n\n  return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nFibonacci(10) // 89\nFibonacci(100) // 超时\nFibonacci(500) // 超时\n")])])]),n("h4",{attrs:{id:"增加函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#增加函数"}},[a._v("#")]),a._v(" 增加函数")]),a._v(" "),n("div",{staticClass:"language-text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function tailFactorial(n, total) {\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n}\n\nfunction factorial(n) {\n  return tailFactorial(n, 1);\n}\n\nfactorial(5) // 120\n")])])]),n("h4",{attrs:{id:"es6-函数默认值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es6-函数默认值"}},[a._v("#")]),a._v(" ES6 函数默认值")]),a._v(" "),n("div",{staticClass:"language-text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function factorial(n, total = 1) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5) // 120\n")])])]),n("h4",{attrs:{id:"严格模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#严格模式"}},[a._v("#")]),a._v(" 严格模式 "),n("a",{attrs:{id:"&#x4E25;&#x683C;&#x6A21;&#x5F0F;"}})]),a._v(" "),n("p",[a._v("ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。")]),a._v(" "),n("p",[a._v("这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。")]),a._v(" "),n("ul",[n("li",[n("code",[a._v("func.arguments")]),a._v("：返回调用时函数的参数。")]),a._v(" "),n("li",[n("code",[a._v("func.caller")]),a._v("：返回调用当前函数的那个函数")])]),a._v(" "),n("h2",{attrs:{id:"尾递归优化实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#尾递归优化实现"}},[a._v("#")]),a._v(" 尾递归优化实现")]),a._v(" "),n("p",[a._v("没有尾递归的时候，可以用 循环 来解决递归爆栈的问题")]),a._v(" "),n("p",[n("code",[a._v("sum")]),a._v("是一个递归函数，参数"),n("code",[a._v("x")]),a._v("是需要累加的值，参数"),n("code",[a._v("y")]),a._v("控制递归次数。一旦指定"),n("code",[a._v("sum")]),a._v("递归 100000 次，就会报错，提示超出调用栈的最大次数")]),a._v(" "),n("div",{staticClass:"language-text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function sum(x, y) {\n  if (y > 0) {\n    return sum(x + 1, y - 1);\n  } else {\n    return x;\n  }\n}\n\nsum(1, 100000)\n// Uncaught RangeError: Maximum call stack size exceeded(…)\n")])])]),n("h3",{attrs:{id:"蹦床函数-trampoline"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#蹦床函数-trampoline"}},[a._v("#")]),a._v(" 蹦床函数（trampoline）")]),a._v(" "),n("div",{staticClass:"language-text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function trampoline(f) {\n  while (f && f instanceof Function) {\n    f = f();\n  }\n  return f;\n}\n// sum 也需要更改\nfunction sum(x, y) {\n  if (y > 0) {\n    return sum.bind(null, x + 1, y - 1);\n  } else {\n    return x;\n  }\n}\n\ntrampoline(sum(1, 100000)) // 100001\n")])])]),n("h3",{attrs:{id:"真正的尾递归优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#真正的尾递归优化"}},[a._v("#")]),a._v(" 真正的尾递归优化")]),a._v(" "),n("div",{staticClass:"language-text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function tco(f) {\n  var value;\n  var active = false;\n  var accumulated = [];\n\n  return function accumulator() {\n    accumulated.push(arguments);\n    if (!active) {\n      active = true;\n      while (accumulated.length) {\n        value = f.apply(this, accumulated.shift());\n      }\n      active = false;\n      return value;\n    }\n  };\n}\n\nvar sum = tco(function(x, y) {\n  if (y > 0) {\n    return sum(x + 1, y - 1)\n  }\n  else {\n    return x\n  }\n});\n\nsum(1, 100000)\n// 100001\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);