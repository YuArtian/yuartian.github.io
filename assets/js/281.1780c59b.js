(window.webpackJsonp=window.webpackJsonp||[]).push([[281],{646:function(e,r,a){"use strict";a.r(r);var o=a(45),v=Object(o.a)({},(function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"webpack中loader和plugin的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack中loader和plugin的区别"}},[e._v("#")]),e._v(" webpack中loader和plugin的区别")]),e._v(" "),a("p",[a("strong",[e._v("一、webpack的打包原理")])]),e._v(" "),a("ol",[a("li",[e._v("识别入口文件")]),e._v(" "),a("li",[e._v("通过逐层识别模块依赖(Commonjs、amd或者es6的import，webpack都会对其进行分析，来获取代码的依赖)")]),e._v(" "),a("li",[e._v("webpack做的就是分析代码，转换代码，编译代码，输出代码")]),e._v(" "),a("li",[e._v("最终形成打包后的代码")])]),e._v(" "),a("p",[a("strong",[e._v("二、什么是loader")])]),e._v(" "),a("blockquote",[a("p",[e._v("https://webpack.docschina.org/api/loaders/")])]),e._v(" "),a("p",[e._v("loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中")]),e._v(" "),a("ol",[a("li",[e._v("处理一个文件可以使用多个loader，loader的执行顺序和配置中的顺序是相反的，即最后一个loader最先执行，第一个loader最后执行")]),e._v(" "),a("li",[e._v("第一个执行的loader接收源文件内容作为参数，其它loader接收前一个执行的loader的返回值作为参数，最后执行的loader会返回此模块的JavaScript源码")])]),e._v(" "),a("p",[e._v("所谓 loader 只是一个导出为函数的 JavaScript 模块。"),a("a",{attrs:{href:"https://github.com/webpack/loader-runner",target:"_blank",rel:"noopener noreferrer"}},[e._v("loader runner"),a("OutboundLink")],1),e._v(" 会调用这个函数，然后把上一个 loader 产生的结果或者资源文件(resource file)传入进去。函数的 "),a("code",[e._v("this")]),e._v(" 上下文将由 webpack 填充，并且 "),a("a",{attrs:{href:"https://github.com/webpack/loader-runner",target:"_blank",rel:"noopener noreferrer"}},[e._v("loader runner"),a("OutboundLink")],1),e._v(" 具有一些有用方法，可以使 loader 改变为异步调用方式，或者获取 query 参数。")]),e._v(" "),a("p",[e._v("第一个 loader 的传入参数只有一个：资源文件(resource file)的内容。compiler 需要得到最后一个 loader 产生的处理结果。这个处理结果应该是 "),a("code",[e._v("String")]),e._v(" 或者 "),a("code",[e._v("Buffer")]),e._v("（被转换为一个 string），代表了模块的 JavaScript 源码。另外还可以传递一个可选的 SourceMap 结果（格式为 JSON 对象）")]),e._v(" "),a("p",[e._v("如果是单个处理结果，可以在"),a("strong",[e._v("同步模式")]),e._v("中直接返回。如果有多个处理结果，则必须调用 "),a("code",[e._v("this.callback()")]),e._v("。")]),e._v(" "),a("p",[e._v("在"),a("strong",[e._v("异步模式")]),e._v("中，必须调用 "),a("code",[e._v("this.async()")]),e._v("，来指示 "),a("a",{attrs:{href:"https://github.com/webpack/loader-runner",target:"_blank",rel:"noopener noreferrer"}},[e._v("loader runner"),a("OutboundLink")],1),e._v(" 等待异步结果，它会返回 "),a("code",[e._v("this.callback()")]),e._v(" 回调函数，随后 loader 必须返回 "),a("code",[e._v("undefined")]),e._v(" 并且调用该回调函数")]),e._v(" "),a("h6",{attrs:{id:"异步-loader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步-loader"}},[e._v("#")]),e._v(" 异步 loader")]),e._v(" "),a("p",[e._v("异步loader需要先调用"),a("code",[e._v("this.async()")]),e._v("，执行这个方法后，"),a("code",[e._v("loader-runner")]),e._v("内部会将"),a("code",[e._v("loader")]),e._v("识别为异步的，并返回一个"),a("code",[e._v("callback")])]),e._v(" "),a("p",[a("strong",[e._v("三、什么是plugin")])]),e._v(" "),a("p",[e._v("在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。")]),e._v(" "),a("p",[a("strong",[e._v("四、loader和plugin的区别")])]),e._v(" "),a("p",[e._v("对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程")]),e._v(" "),a("p",[e._v("plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务")])])}),[],!1,null,null,null);r.default=v.exports}}]);