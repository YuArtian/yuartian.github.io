(window.webpackJsonp=window.webpackJsonp||[]).push([[227],{593:function(t,a,o){"use strict";o.r(a);var e=o(45),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,o=t._self._c||a;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"前端路由"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#前端路由"}},[t._v("#")]),t._v(" 前端路由")]),t._v(" "),o("p",[t._v("浏览器历史记录是 栈结构的（后进先出）")]),t._v(" "),o("p",[t._v("内部通过两个栈来管理历史记录：")]),t._v(" "),o("ul",[o("li",[o("p",[t._v("浏览器当前显示的是第一个栈栈顶的地址")])]),t._v(" "),o("li",[o("p",[t._v("后退时，将第一个栈中栈顶的地址放入第二个栈中，此时，浏览器显示为新的栈顶的地址")])]),t._v(" "),o("li",[o("p",[t._v("前进时，就将第二个栈中栈顶的地址放入第一个栈中")])]),t._v(" "),o("li",[o("p",[t._v("如果中间，再次输入新的地址，则将新地址推入第一个栈，清空第二个栈，第二个栈中的历史记录就销毁了")])])]),t._v(" "),o("h2",{attrs:{id:"哈希路由"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#哈希路由"}},[t._v("#")]),t._v(" 哈希路由")]),t._v(" "),o("p",[o("code",[t._v("http://demo.com/#/aaa")])]),t._v(" "),o("p",[t._v("由于路由地址中的哈希值的改变不会刷新页面")]),t._v(" "),o("p",[t._v("利用 "),o("code",[t._v("window.location.hash = '/aaa'")]),t._v(" 改变 hash 值")]),t._v(" "),o("p",[t._v("利用 "),o("code",[t._v("window.onhashchange = function(){...}")]),t._v(" 事件可以监听 hash 值的变化，从而渲染对应路径的组件")]),t._v(" "),o("p",[t._v("问题是，显示在浏览器上的路径比较难看")]),t._v(" "),o("h2",{attrs:{id:"history-api"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#history-api"}},[t._v("#")]),t._v(" History API")]),t._v(" "),o("blockquote",[o("p",[t._v("https://developer.mozilla.org/zh-CN/docs/Web/API/History")])]),t._v(" "),o("p",[t._v("利用浏览器提供的 history api 创建虚拟路由地址，也不会刷新页面，但是在强制刷新的时候需要服务器配合")]),t._v(" "),o("p",[t._v("利用 "),o("code",[t._v("window.onpopstate")]),t._v(" 监听路由的变化")]),t._v(" "),o("h3",{attrs:{id:"window-history-pushstate-null-aaa"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#window-history-pushstate-null-aaa"}},[t._v("#")]),t._v(" "),o("code",[t._v("window.history.pushState({}, null, 'aaa')")]),t._v("：")]),t._v(" "),o("p",[o("code",[t._v("pushState()")]),t._v(" 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个URL")]),t._v(" "),o("p",[t._v("注意 "),o("code",[t._v("pushState()")]),t._v(" 绝对不会触发 "),o("code",[t._v("hashchange")]),t._v(" 事件，即使新的URL与旧的URL仅哈希不同也是如此")]),t._v(" "),o("h3",{attrs:{id:"window-history-replacestate-stateobj-title-url"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#window-history-replacestate-stateobj-title-url"}},[t._v("#")]),t._v(" "),o("code",[t._v("window.history.replaceState(stateObj, title[, url])")])]),t._v(" "),o("p",[t._v("修改了当前的历史记录项而不是新建一个")]),t._v(" "),o("h3",{attrs:{id:"window-history-back"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#window-history-back"}},[t._v("#")]),t._v(" "),o("code",[t._v("window.history.back()")])]),t._v(" "),o("p",[t._v("在会话历史记录中向后移动一页。如果没有上一页，则此方法调用不执行任何操作")]),t._v(" "),o("h3",{attrs:{id:"window-history-forward"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#window-history-forward"}},[t._v("#")]),t._v(" "),o("code",[t._v("window.history.forward()")])]),t._v(" "),o("p",[t._v("在会话历史中向前移动一页。它与使用"),o("code",[t._v("delta")]),t._v("参数为1时调用 "),o("code",[t._v("history.go(delta)")]),t._v("的效果相同")]),t._v(" "),o("h3",{attrs:{id:"window-history-go-delta"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#window-history-go-delta"}},[t._v("#")]),t._v(" "),o("code",[t._v("window.history.go(delta)")])]),t._v(" "),o("p",[o("code",[t._v("go()")]),t._v("方法从会话历史记录中加载特定页面。你可以使用它在历史记录中前后移动，具体取决于"),o("code",[t._v("delta")]),t._v("参数的值")]),t._v(" "),o("ul",[o("li",[t._v("负值表示向后移动，正值表示向前移动")]),t._v(" "),o("li",[t._v("如果未向该函数传参 或 "),o("code",[t._v("delta")]),t._v(" 等于0，则该函数与调用"),o("code",[t._v("location.reload()")]),t._v("具有相同的效果")])]),t._v(" "),o("h2",{attrs:{id:"监听路由变化"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#监听路由变化"}},[t._v("#")]),t._v(" 监听路由变化")]),t._v(" "),o("blockquote",[o("p",[t._v("多次设置相同的 hash 值，并不会多次触发 onpopstate 和 hashchange")]),t._v(" "),o("p",[t._v("Histroy api 只会触发 onpopstate")])]),t._v(" "),o("h3",{attrs:{id:"window-onpopstate-function-event-event-state"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#window-onpopstate-function-event-event-state"}},[t._v("#")]),t._v(" "),o("code",[t._v("window.onpopstate=function(event){//event.state}")])]),t._v(" "),o("p",[t._v("每当处于激活状态的历史记录条目发生变化时， "),o("code",[t._v("popstate")]),t._v(" 事件就会在 "),o("strong",[t._v("对应window")]),t._v(" 对象上触发")]),t._v(" "),o("p",[o("strong",[t._v("hash 值的改变也会引起 onpopstate 的变化")])]),t._v(" "),o("p",[t._v("其中的 "),o("code",[t._v("event.state")]),t._v(" 就是 pushState 或者 replaceState 时设置的 state")]),t._v(" "),o("h3",{attrs:{id:"window-onhashchange-function"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#window-onhashchange-function"}},[t._v("#")]),t._v(" "),o("code",[t._v("window.onhashchange = function(){...}")])]),t._v(" "),o("p",[t._v("当 hash 变化的时候，onhashchange 才会发生变化")]),t._v(" "),o("h2",{attrs:{id:"histroy-与-hash-模式相比的优点"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#histroy-与-hash-模式相比的优点"}},[t._v("#")]),t._v(" Histroy 与 hash 模式相比的优点")]),t._v(" "),o("p",[t._v("在某种意义上，调用 "),o("code",[t._v("pushState()")]),t._v(" 与 设置 "),o("code",[t._v('window.location = "#foo"')]),t._v(" 类似，二者都会在当前页面创建并激活新的历史记录。但 "),o("code",[t._v("pushState()")]),t._v(" 具有如下几条优点：")]),t._v(" "),o("ul",[o("li",[t._v("新的 URL 可以是与当前URL同源的任意URL 。相反，只有在修改哈希时，设置 "),o("code",[t._v("window.location")]),t._v(" 才能是同一个 "),o("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document",target:"_blank",rel:"noopener noreferrer"}},[o("code",[t._v("document")]),o("OutboundLink")],1)]),t._v(" "),o("li",[t._v("如果你不想改URL，就不用改。相反，设置 "),o("code",[t._v('window.location = "#foo";')]),t._v("在当前哈希不是 "),o("code",[t._v("#foo")]),t._v(" 时， 才能创建新的历史记录项")]),t._v(" "),o("li",[t._v("你可以将任意数据和新的历史记录项相关联。而基于哈希的方式，要把所有相关数据编码为短字符串")]),t._v(" "),o("li",[t._v("如果 "),o("code",[t._v("标题")]),t._v(" 随后还会被浏览器所用到，那么这个数据是可以被使用的（哈希则不是）")])])])}),[],!1,null,null,null);a.default=v.exports}}]);