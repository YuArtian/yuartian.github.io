(window.webpackJsonp=window.webpackJsonp||[]).push([[273],{637:function(t,e,r){"use strict";r.r(e);var v=r(45),a=Object(v.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"vuerouter是如何实现无刷新跳转的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vuerouter是如何实现无刷新跳转的"}},[t._v("#")]),t._v(" VueRouter是如何实现无刷新跳转的")]),t._v(" "),r("h3",{attrs:{id:"简答"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简答"}},[t._v("#")]),t._v(" 简答")]),t._v(" "),r("p",[t._v("利用 history api 或者 hash change 的方式，触发无刷新的改变页面 url")]),t._v(" "),r("p",[t._v("利用 Vue 响应式原理，将路由表设置为响应式的")]),t._v(" "),r("p",[t._v("通过 onpopstate 或者 onhashchange 监听 url 变化，在 url 改变时，同时改变路由表")]),t._v(" "),r("p",[t._v("从而触发 Vue 响应式更新视图")]),t._v(" "),r("p",[t._v("在 url 改变时，切换不同的组件")]),t._v(" "),r("h3",{attrs:{id:"设置监听"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设置监听"}},[t._v("#")]),t._v(" 设置监听")]),t._v(" "),r("p",[t._v("在 vue router 初始化的时候，会首先根据用户所选的模式（mode），默认是 hash模式，创建对应的历史管理实例")]),t._v(" "),r("p",[t._v("然后，基于对应的模式，设置监听路径变化的方法")]),t._v(" "),r("h3",{attrs:{id:"路由匹配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#路由匹配"}},[t._v("#")]),t._v(" 路由匹配")]),t._v(" "),r("p",[t._v("使用 vue router时，需要传入 routes 配置，这个配置描述了 路由 和 组件 的对应关系，vue router 内部会重新格式化一下，主要是为了方便后续的查找")]),t._v(" "),r("p",[t._v("在 url 变化的时候，vue router 会动态的匹配当前的路径，根据配置寻找当前路径对应的 组件 和 其父组件")]),t._v(" "),r("p",[t._v("返回 "),r("code",[t._v("{path: '/x/xx', matched: [{}]}")]),t._v(" 的对应关系，之后会进行更新视图")]),t._v(" "),r("h3",{attrs:{id:"更新视图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#更新视图"}},[t._v("#")]),t._v(" 更新视图")]),t._v(" "),r("p",[t._v("由于 Vue 是响应式的，数据变化会自动更新视图")]),t._v(" "),r("p",[t._v("使用 "),r("code",[t._v("Vue.util.defineReactive()")]),t._v(" 方法，将 _route 属性定义为响应式属性，值为当前匹配到的对应关系")]),t._v(" "),r("p",[t._v("监听到路由变化时，重新给 _route 赋值，从而触发更新")]),t._v(" "),r("h3",{attrs:{id:"渲染视图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#渲染视图"}},[t._v("#")]),t._v(" 渲染视图")]),t._v(" "),r("p",[t._v("vue router 渲染视图依靠 router-view 组件，router-view 是函数式组件")]),t._v(" "),r("p",[t._v("vue-router 根据匹配到的组件数组（this.$route.matched）进行递归")]),t._v(" "),r("p",[t._v("依据当前 router-view 组件是否有父级 router-view（"),r("code",[t._v("this.\\$vnode.parent.data.routerView === true")]),t._v("）")]),t._v(" "),r("p",[t._v("来确定自己的 depth 层级，从而实现在对应层级的 router-view 上渲染")])])}),[],!1,null,null,null);e.default=a.exports}}]);