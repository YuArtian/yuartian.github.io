(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{413:function(t,a,e){"use strict";e.r(a);var n=e(45),s=Object(n.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"函数是一等公民"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数是一等公民"}},[t._v("#")]),t._v(" 函数是一等公民")]),t._v(" "),e("p",[t._v("JavaScript 中的函数非常灵活，其根本原因在于 JavaScript 中的函数就是一种特殊的对象，我们把 JavaScript 中的函数称为一等公民 (First Class Function)")]),t._v(" "),e("p",[t._v("函数可以赋值给一个变量，也可以作为函数的参数，还可以作为函数的返回值。如果某个编程语言的函数，可以和这个语言的数据类型做一样的事情，我们就把这个语言中的函数称为一等公民")]),t._v(" "),e("h2",{attrs:{id:"函数的本质"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数的本质"}},[t._v("#")]),t._v(" 函数的本质")]),t._v(" "),e("p",[t._v("在 JavaScript 中，函数是一种特殊的对象")]),t._v(" "),e("ul",[e("li",[t._v("函数作为一个对象，它有自己的属性和值，所以函数关联了基础的属性和值")]),t._v(" "),e("li",[t._v("函数之所以称为特殊的对象，这个特殊的地方是函数可以 被调用")]),t._v(" "),e("li",[t._v("一个函数被调用时，它还需要关联相关的 执行上下文")])]),t._v(" "),e("h3",{attrs:{id:"可调用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可调用"}},[t._v("#")]),t._v(" 可调用")]),t._v(" "),e("p",[t._v("为函数对象添加了两个隐藏属性 name 和 code")]),t._v(" "),e("p",[t._v("name 标识函数名，匿名函数为 anonymous")]),t._v(" "),e("p",[t._v("code 表示函数代码，以字符串的形式存储在内存中")]),t._v(" "),e("p",[t._v("当执行到一个函数调用语句时，V8 便会从函数对象中取出 code 属性值，也就是函数代码，然后再解释执行这段函数代码，这就实现了函数可以调用的特性")]),t._v(" "),e("h3",{attrs:{id:"可继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可继承"}},[t._v("#")]),t._v(" 可继承")]),t._v(" "),e("p",[t._v("函数提供 prototype 属性，用于实现基于原型链的继承")]),t._v(" "),e("h2",{attrs:{id:"函数的定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数的定义"}},[t._v("#")]),t._v(" 函数的定义")]),t._v(" "),e("h4",{attrs:{id:"函数声明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数声明"}},[t._v("#")]),t._v(" 函数声明")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function name () {}\n")])])]),e("p",[t._v("函数声明属于 语句，语句会被提升而且函数是整体提升")]),t._v(" "),e("p",[t._v("函数声明一定要有函数名，否则会报错")]),t._v(" "),e("h4",{attrs:{id:"函数表达式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数表达式"}},[t._v("#")]),t._v(" 函数表达式")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var foo = function (){\n    console.log('foo')\n}\n")])])]),e("p",[t._v("函数表达式属于 表达式，function 函数部分 不会参与 变量提升")]),t._v(" "),e("h4",{attrs:{id:"function-构造函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#function-构造函数"}},[t._v("#")]),t._v(" Function 构造函数")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("new Function ([arg1[, arg2[, ...argN]],] functionBody)\n")])])]),e("h4",{attrs:{id:"箭头函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[t._v("#")]),t._v(" "),e("RouterLink",{attrs:{to:"/Index/javascript基础/函数/箭头函数.html"}},[t._v("箭头函数")])],1),t._v(" "),e("p",[t._v("ES6 允许使用“箭头”（"),e("code",[t._v("=>")]),t._v("）定义函数")]),t._v(" "),e("h3",{attrs:{id:"函数声明与函数表达式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数声明与函数表达式"}},[t._v("#")]),t._v(" 函数声明与函数表达式")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("foo() // 'foo'\nfunction foo(){\n    console.log('foo')\n}\n")])])]),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("foo() //Uncaught TypeError: foo is not a function\nvar foo = function (){\n    console.log('foo')\n}\n")])])]),e("p",[t._v("当执行这段代码的时候，V8 在编译阶段会先查找声明语句，你可以把这段代码拆分为下面两行代码：")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var foo = undefined\nfoo = function (){\n    console.log('foo')\n}\n")])])]),e("p",[t._v("第一行是声明语句，所以 V8 在解析阶段，就会在作用域中创建该对象，并将该对象设置为 undefined")]),t._v(" "),e("p",[t._v("第二行是函数表达式，在编译阶段，V8 并不会处理 函数表达式")]),t._v(" "),e("p",[t._v("所以也就不会将该函数表达式提升到作用域中了")]),t._v(" "),e("p",[t._v("那么在函数表达式之前调用该函数 foo，此时的 foo 只是指向了 undefined，所以就相当于调用一个 undefined，而 undefined 只是一个原生对象，并不是函数，所以当然会报错了")]),t._v(" "),e("h2",{attrs:{id:"函数的参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数的参数"}},[t._v("#")]),t._v(" 函数的参数")]),t._v(" "),e("h3",{attrs:{id:"默认值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#默认值"}},[t._v("#")]),t._v(" 默认值")]),t._v(" "),e("h4",{attrs:{id:"默认值配合结构的写法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#默认值配合结构的写法"}},[t._v("#")]),t._v(" 默认值配合结构的写法")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 写法一\nfunction m1({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\n// 写法二\nfunction m2({x, y} = { x: 0, y: 0 }) {\n  return [x, y];\n}\n")])])]),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 函数没有参数的情况\nm1() // [0, 0]\nm2() // [0, 0]\n\n// x 和 y 都有值的情况\nm1({x: 3, y: 8}) // [3, 8]\nm2({x: 3, y: 8}) // [3, 8]\n\n// x 有值，y 无值的情况\nm1({x: 3}) // [3, 0]\nm2({x: 3}) // [3, undefined]\n\n// x 和 y 都无值的情况\nm1({}) // [0, 0];\nm2({}) // [undefined, undefined]\n\nm1({z: 3}) // [0, 0]\nm2({z: 3}) // [undefined, undefined]\n")])])]),e("h4",{attrs:{id:"null-不会触发参数默认值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#null-不会触发参数默认值"}},[t._v("#")]),t._v(" null 不会触发参数默认值")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function foo(x = 5, y = 6) {\n  console.log(x, y);\n}\n\nfoo(undefined, null)\n// 5 null\n")])])]),e("p",[t._v("上面代码中，"),e("code",[t._v("x")]),t._v("参数对应"),e("code",[t._v("undefined")]),t._v("，结果触发了默认值，"),e("code",[t._v("y")]),t._v("参数等于"),e("code",[t._v("null")]),t._v("，就没有触发默认值")]),t._v(" "),e("h4",{attrs:{id:"函数-length-属性不再准确"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数-length-属性不再准确"}},[t._v("#")]),t._v(" 函数 length 属性不再准确")]),t._v(" "),e("p",[t._v("指定了默认值以后，函数的"),e("code",[t._v("length")]),t._v("属性，将返回没有指定默认值的参数个数")]),t._v(" "),e("p",[t._v("也就是说，指定了默认值后，"),e("code",[t._v("length")]),t._v("属性将失真")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("(function (a) {}).length // 1\n(function (a = 5) {}).length // 0\n(function (a, b, c = 5) {}).length // 2\n")])])]),e("h4",{attrs:{id:"参数作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参数作用域"}},[t._v("#")]),t._v(" 参数作用域")]),t._v(" "),e("p",[t._v("一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域")]),t._v(" "),e("p",[t._v("等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var x = 1;\n\nfunction f(x, y = x) {\n  console.log(y);\n}\n\nf(2) // 2\n")])])]),e("p",[t._v("上面代码中，参数"),e("code",[t._v("y")]),t._v("的默认值等于变量"),e("code",[t._v("x")]),t._v("。调用函数"),e("code",[t._v("f")]),t._v("时，参数形成一个单独的作用域。在这个作用域里面，默认值变量"),e("code",[t._v("x")]),t._v("指向第一个参数"),e("code",[t._v("x")]),t._v("，而不是全局变量"),e("code",[t._v("x")]),t._v("，所以输出是"),e("code",[t._v("2")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let x = 1;\n\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\n\nf() // 1\n")])])]),e("p",[t._v("上面代码中，函数"),e("code",[t._v("f")]),t._v("调用时，参数"),e("code",[t._v("y = x")]),t._v("形成一个单独的作用域。这个作用域里面，变量"),e("code",[t._v("x")]),t._v("本身没有定义，所以指向外层的全局变量"),e("code",[t._v("x")]),t._v("。函数调用时，函数体内部的局部变量"),e("code",[t._v("x")]),t._v("影响不到默认值变量"),e("code",[t._v("x")]),t._v("。")]),t._v(" "),e("p",[t._v("如果此时，全局变量"),e("code",[t._v("x")]),t._v("不存在，就会报错")])])}),[],!1,null,null,null);a.default=s.exports}}]);