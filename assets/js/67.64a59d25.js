(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{429:function(t,a,s){"use strict";s.r(a);var r=s(45),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"堆和栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆和栈"}},[t._v("#")]),t._v(" 堆和栈")]),t._v(" "),s("h1",{attrs:{id:"栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),s("p",[t._v("浏览器一加载页面就形成了一个栈内存，这个栈内存用来执行代码")]),t._v(" "),s("p",[t._v("栈是内存中一块用于存储局部变量和函数参数的线性结构，遵循着先进后出的原则，数据只能顺序的入栈，顺序的出栈")]),t._v(" "),s("p",[t._v("栈是内存中一片连续区域一种形式化的描述，数据入栈和出栈的操作仅仅是栈指针在内存地址上的上下移动")]),t._v(" "),s("p",[t._v("内存中栈区的数据，在函数调用结束后，就会自动的出栈，不需要程序进行操作，操作系统会自动执行，换句话说：栈中的变量在函数调用结束后，就会消失")]),t._v(" "),s("p",[t._v("因此栈的特点：轻量，不需要手动管理，函数调时创建，调用结束则消失")]),t._v(" "),s("p",[s("img",{attrs:{src:"",alt:"栈空间"}})]),t._v(" "),s("h1",{attrs:{id:"堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[t._v("#")]),t._v(" 堆")]),t._v(" "),s("p",[t._v("堆可以简单的认为是一大块内存空间，操作系统不提供自动清理，JS引擎会有回收机制来防止内存溢出")]),t._v(" "),s("p",[t._v("每个堆都有一个 16进制的地址，以供访问")]),t._v(" "),s("h1",{attrs:{id:"存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#存储"}},[t._v("#")]),t._v(" 存储")]),t._v(" "),s("p",[t._v("一般来说，对于原始类型，数据本身是存在栈内，对于对象类型，在栈中存的只是一个堆内地址的引用")]),t._v(" "),s("p",[s("img",{attrs:{src:"",alt:""}})])])}),[],!1,null,null,null);a.default=v.exports}}]);